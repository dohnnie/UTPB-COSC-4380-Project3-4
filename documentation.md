# Project 3
We did the same thing as we did the other projects where we jumped into a voice chat on Discord and did pair programming. The only resource we used was the wikipedia page for [Diffie-Hellman](https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange), and [RSA](https://en.wikipedia.org/wiki/RSA_cryptosystem). fastMod wasn't working, and we didn't feel like trying to figure out what was wrong with it, so we just used the modPow method from BigInteger. Other than that we used the getPrime and getGenerator methods in the Crypto class. For some reason getPrimes wasn't generating good enough prime numbers for RSA to encrypt/decrypt properly so we also just used the ProbablePrime to get the prime numbers. When authenticating and decrypting the message, because we can't tell if a message is already signed or encrypted, the authetication, and decryption methods just return a string of the message encoded in UTF-8 rather than the actual message.

For AES implementation, we used the same method of pair programming and we used the Wikipedia page for [AES](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard) and [Key-Expansion](https://en.wikipedia.org/wiki/AES_key_schedule). Although it was not specified in the project requirements, we deemed AES-128 the best for this situation, especially considering the example key and plaintext are 16 bytes each. We designed the encryption to work with any size plain text. Any key > 16 bytes is shortened, with 16 characters being the minimum for the input. A unique IV value is generated for every encryption, which must be known and shared publicly for decryption. Overall, the project went off without a hitch.